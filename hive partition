#!/bin/bash

# File containing the list of tables
TABLE_FILE="tables.txt"

# Check if file exists
if [[ ! -f "$TABLE_FILE" ]]; then
    echo "Table file not found!"
    exit 1
fi

# Function to drop partitions from a table
drop_partitions() {
    local table=$1

    # Fetch all available partitions for the table using TSV format for cleaner output
    echo "Fetching partitions for table: $table"
    
    partitions=$(beeline --outputformat=tsv2 -e "SHOW PARTITIONS $table;" 2>/dev/null)

    # Check if partitions exist
    if [[ -z "$partitions" ]]; then
        echo "No partitions found for table: $table"
        return
    fi

    # Loop over each partition and drop it
    while IFS= read -r partition; do
        if [[ -n "$partition" ]]; then
            echo "Processing partition $partition for table $table"

            # Convert partition into the correct format for ALTER TABLE statement
            # e.g., from "load_date=2024-07-21/country_cd=US" or "load_date=2024-07-21"
            # to "load_date='2024-07-21', country_cd='US'"
            formatted_partition=$(echo "$partition" | sed "s/=/='/g" | sed "s/\//', /g" | sed "s/$/'/g")

            # Construct the ALTER TABLE command to drop the partition
            SQL_CMD="ALTER TABLE $table DROP PARTITION ($formatted_partition) PURGE;"
            echo "Executing: $SQL_CMD"

            # Execute the command using Beeline
            beeline --outputformat=tsv2 -e "$SQL_CMD"

            # Check if the command was successful
            if [[ $? -eq 0 ]]; then
                echo "Successfully dropped partition $partition from table $table"
            else
                echo "Failed to drop partition $partition from table $table"
            fi
        fi
    done <<< "$partitions"
}

# Iterate over each table name in the file
while IFS= read -r TABLE_NAME; do
    if [[ -n "$TABLE_NAME" ]]; then
        # Call the function to drop partitions for the current table
        drop_partitions "$TABLE_NAME"
    fi
done < "$TABLE_FILE"
